/*
 * Copyright 2020 Spotify AB.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package magnolify.codegen

import java.io.PrintWriter
import java.nio.file.Path

import org.typelevel.paiges._

case class Module(namespace: String, imports: List[String], caseClass: CaseClass) {
  def doc: Doc = {
    val comment =
      Doc.text("// Generated by magnolify-codegen, DO NOT EDIT!") + Doc.hardLine +
        Doc.text(s"// $namespace.${caseClass.name}.scala") + Doc.hardLine
    val pkg = Doc.text("package") + Doc.space + Doc.text(namespace) + Doc.hardLine
    val prefix = imports
      .map(s => Doc.hardLine + Doc.text("import") + Doc.space + Doc.text(s))
      .reduceOption(_ + _)
      .map(_ + Doc.hardLine)
      .getOrElse(Doc.empty)
    comment + pkg + prefix + Doc.hardLine + caseClass.doc
  }

  def saveTo(dir: Path): Path = {
    val outDir = namespace.split('.').foldLeft(dir)(_.resolve(_))
    outDir.toFile.mkdirs()
    val outFile = outDir.resolve(caseClass.name + ".scala")
    val writer = new PrintWriter(outFile.toFile)
    doc.writeTo(100, writer)
    writer.close()
    outFile
  }
}

object Module {
  def distinct(modules: List[Module]): List[Module] = modules
    .groupBy(m => (m.namespace, m.caseClass.name))
    .values
    .map { ms =>
      val distinct = ms.toSet
      require(
        distinct.size == 1,
        (Doc.text("Inconsistent module duplication:") + Doc.hardLine +
          Doc.intercalate(Doc.hardLine, distinct.map(_.doc))).render(100)
      )
      distinct.head
    }
    .toList
}

case class CaseClass(
  name: String,
  fields: List[Field],
  annotations: List[String],
  companion: Option[Companion]
) {
  def doc: Doc = {
    val prefix = annotations
      .map(Doc.text(_) + Doc.hardLine)
      .reduceOption(_ + _)
      .getOrElse(Doc.empty) +
      Doc.text("case class") + Doc.space + Doc.text(name) + Doc.char('(')
    val suffix = Doc.char(')')
    val body = Doc.intercalate(Doc.char(',') + Doc.lineOrSpace, fields.map(_.doc))
    val cc = body.tightBracketBy(prefix, suffix)
    val obj = companion.map(c => Doc.hardLine * 2 + c.doc).getOrElse(Doc.empty)
    cc + obj
  }
}

case class Field(label: String, tpe: String, annotations: List[String], default: Option[String]) {
  def doc: Doc = {
    val prefix = annotations
      .map(Doc.text(_) + Doc.lineOrSpace)
      .reduceOption(_ + _)
      .getOrElse(Doc.empty)
    val body = Doc.text(label) + Doc.char(':') + Doc.space + Doc.text(tpe)
    val suffix = default
      .map(d => Doc.space + Doc.char('=') + Doc.space + Doc.text(d))
      .getOrElse(Doc.empty)
    prefix + body + suffix
  }
}

case class Companion(name: String, caseClasses: List[CaseClass]) {
  def doc: Doc = {
    val prefix = Doc.text("object") + Doc.space + Doc.text(name) + Doc.space + Doc.char('{')
    val suffix = Doc.char('}')
    val body = caseClasses.map(c => Doc.hardLine + c.doc).reduce(_ + _)
    body.bracketBy(prefix, Doc.hardLine + suffix)
  }
}

sealed trait Repetition

object Repetition {
  case object Required extends Repetition
  case object Nullable extends Repetition
  case object Repeated extends Repetition
}
